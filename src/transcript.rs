use sha2::{digest::Digest, Sha256};
use secp256kfun::hash::Tag;

#[derive(Clone, Debug)]
pub struct Transcript {
    // t: Vec<u8>;
    hasher: Sha256,
}

impl Transcript {
    pub fn new(label: &'static [u8]) -> Transcript {
        let hasher = Sha256::default().tag_vectored([label].into_iter());
        Transcript {
            hasher: hasher
        }
    }
    pub fn new_untagged() -> Transcript {
        let hasher = Sha256::default();
        Transcript {
            hasher: hasher
        }
    }
    pub fn append_message(&mut self, message: &[u8]) {
        self.hasher.update(message);
    }
    pub fn challenge_bytes(&self) -> [u8; 32] {
        let mut tmp = self.hasher.clone();
        let zeros = [0u8; 8];
        tmp.update(zeros);
        tmp.finalize().into()
    }
}

#[cfg(test)]
mod tests{
    use super::*;
    #[test]
    fn transcript() {
        let mut transcript = Transcript::new("Bulletproofs_pp/v0/commitment".as_bytes());

        let tmp = transcript.hasher.clone();
        assert_eq!(tmp.finalize()[..], [0x5B, 0x4B, 0xAA, 0x6F, 0xF2, 0x26, 0x74, 0x31, 0x79, 0x7B, 0x06, 0xAD, 0xF9, 0x07, 0x2D, 0x88, 0x73, 0x06, 0xF4, 0xF3, 0x69, 0xF6, 0x7E, 0xB7, 0xE7, 0x6C, 0xA2, 0xD2, 0x88, 0xB4, 0x7A, 0xCF]);

        let result = transcript.challenge_bytes();
        assert_eq!(result[..], [ 0x21, 0x2F, 0xB6, 0x4F, 0x9D, 0x8C, 0x3B, 0xC5, 0xF6, 0x91, 0x15, 0xEE, 0x74, 0xF5, 0x12, 0x67, 0x8A, 0x41, 0xC6, 0x85, 0x1A, 0x79, 0x14, 0xFC, 0x48, 0x15, 0xC7, 0x2D, 0xF8, 0x63, 0x8F, 0x1B ]);

        transcript.append_message(&[0, 1, 2]);
        let result = transcript.challenge_bytes();
        assert_eq!(result[..], [ 0x8D, 0xAA, 0xB7, 0x7E, 0x3C, 0x6A, 0x9E, 0xEC, 0x72, 0x7E, 0x3E, 0xB7, 0x10, 0x03, 0xF0, 0xE9, 0x69, 0x4D, 0xAA, 0x96, 0xCE, 0x98, 0xBB, 0x39, 0x1C, 0x2F, 0x7C, 0x2E, 0x1C, 0x17, 0x78, 0x6D ]);

    }
}

